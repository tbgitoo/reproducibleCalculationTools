substr(destination_root,0,nchar(destination_root)-1)
path="/particleShearEvaluation"
orign_root=""/Library/Frameworks/R.framework/Versions/4.0/Resources/library/"
orign_root="/Library/Frameworks/R.framework/Versions/4.0/Resources/library/"
origin_root="/Library/Frameworks/R.framework/Versions/4.0/Resources/library/"
if(nchar(origin_root)>1)#
    {#
        if(substr(origin_root,nchar(origin_root),nchar(origin_root))=="/")#
        {#
            origin_root=substr(origin_root,0,nchar(origin_root)-1)#
        }#
    }
origin_root
path
path="/particleShearEvaluation/"
if(nchar(path)>1)#
    {#
        if(substr(path,nchar(path),nchar(path))=="/")#
        {#
            path=substr(path,0,nchar(path)-1)#
        }#
    }
path
substr(path,0,0)
substr(path,0,1)
substr(path,1,nchar(path))
substr(path,2,nchar(path))
substr(path,1,1)
substr(path,1,2)
substr(path,1,1)
system.file(".",package="particleShearEvaluation")
system.file("",package="particleShearEvaluation")
split_tensor_and_overview_data(origin_root=system.file("",package="particleShearEvaluation"),path="","full_python_simulation_output_example.txt")
library(particleShearEvaluation)
split_tensor_and_overview_data(origin_root=system.file("",package="particleShearEvaluation"),path="","full_python_simulation_output_example.txt")
library(particleShearEvaluation)
split_tensor_and_overview_data(origin_root=system.file("",package="particleShearEvaluation"),path="","full_python_simulation_output_example.txt")
split_tensor_and_overview_data(origin_root=system.file("",package="particleShearEvaluation"),path="","full_python_simulation_output_example.txt",overwrite=TRUE)
getwd()
help(save)
split_tensor_and_overview_data(origin_root=system.file("",package="particleShearEvaluation"),path="","full_python_simulation_output_example.txt")
library(particleShearEvaluation)
system.file("split",package="particleShearEvaluation")
system.file("split/stress_full_python_simulation_output_example.rda",package="particleShearEvaluation")
path=system.file("split/stress_full_python_simulation_output_example.rda",package="particleShearEvaluation")#
stress_curve=read_stress_curve_from_rda_file(path)
colnames(stress_curve)
plot(strain ~ t, stress_curve,type="l",xlab="t[s]",ylab="strain [-], stress[kPa]")#
lines(stress_curve$t, stress_curve$shear_stress_from_internal_stress_tensor/1000,type="l",col="red")#
legend("bottomleft",legend=c("strain","stress"),lty=c(1,1),col=c("black","red"))
path=system.file("full_python_simulation_output_example.txt",package="particleShearEvaluation")
path
path=system.file("full_python_simulation_output_example.txt",package="particleShearEvaluation")#
stress_tensor_data=read_stress_tensor_data_from_file(path)
dim(stress_tensor_data)
colnames(stress_tensor_data)
stress_tensor_data$index[1:10]
read_stress_tensor_data_from_file
help(data.frame)
stress_tensor_symmetry_Love_Weber=stress_tensor_data$stress_tensor_Love_Weber_01-stress_tensor_data$stress_tensor_Love_Weber_10#
plot(stress_tensor_data$t,stress_tensor_symmetry_Love_Weber)
stress_tensor_symmetry_Love_Weber=stress_tensor_data$stress_tensor_Love_Weber_01-stress_tensor_data$stress_tensor_Love_Weber_10#
plot(stress_tensor_data$t,stress_tensor_symmetry_Love_Weber,type="l")
stress_tensor_symmetry_Love_Weber=stress_tensor_data$stress_tensor_Love_Weber_01-stress_tensor_data$stress_tensor_Love_Weber_10#
plot(stress_tensor_data$t,stress_tensor_symmetry_Love_Weber,type="l", ylim=c(-20,20))
stress_tensor_symmetry_Love_Weber=stress_tensor_data$stress_tensor_Love_Weber_01-stress_tensor_data$stress_tensor_Love_Weber_10#
plot(stress_tensor_data$t,stress_tensor_symmetry_Love_Weber,type="l", ylim=c(-20,20),main="Asymmetry: Love-Weber",ylab="Stress tensor asymmetry [Pa]")
stress_tensor_symmetry_Otsuki=stress_tensor_data$stress_tensor_peculiar_acceleration_otsuki_01-stress_tensor_data$stress_tensor_peculiar_acceleration_otsuki_10#
plot(stress_tensor_data$t,stress_tensor_symmetry_Otsuki,type="l", ylim=c(-20,20),main="Asymmetry: Otsuki",ylab="Stress tensor asymmetry [Pa]")
stress_tensor_symmetry_Otsuki=stress_tensor_data$stress_tensor_peculiar_acceleration_otsuki_01-stress_tensor_data$stress_tensor_peculiar_acceleration_otsuki_10#
plot(stress_tensor_data$t,stress_tensor_symmetry_Otsuki,type="l", ylim=c(-20,20),main="Asymmetry: Otsuki correction term",ylab="Stress tensor asymmetry [Pa]")
stress_tensor_symmetry_external=stress_tensor_data$stress_tensor_from_external_forces_01-stress_tensor_data$stress_tensor_from_external_forces_10#
plot(stress_tensor_data$t,stress_tensor_symmetry_external,type="l", ylim=c(-20,20),main="Asymmetry: Stress tensor from surface forces",ylab="Stress tensor asymmetry [Pa]")
stress_tensor_symmetry_linear_acceleration=stress_tensor_data$stress_tensor_linear_acceleration_01-stress_tensor_data$stress_tensor_linear_acceleration_10#
plot(stress_tensor_data$t,stress_tensor_linear_acceleration_01,type="l", ylim=c(-20,20),main="Asymmetry: Linear acceleration tensor",ylab="Stress tensor asymmetry [Pa]")
stress_tensor_symmetry_linear_acceleration=stress_tensor_data$stress_tensor_linear_acceleration_01-stress_tensor_data$stress_tensor_linear_acceleration_10#
plot(stress_tensor_data$t,stress_tensor_symmetry_linear_acceleration,type="l", ylim=c(-20,20),main="Asymmetry: Linear acceleration tensor",ylab="Stress tensor asymmetry [Pa]")
stress_tensor_asymmetry_linear_acceleration=stress_tensor_data$stress_tensor_linear_acceleration_01-stress_tensor_data$stress_tensor_linear_acceleration_10#
plot(stress_tensor_data$t,stress_tensor_asymmetry_linear_acceleration,type="l", ylim=c(-20,20),main="Asymmetry: Linear acceleration tensor",ylab="Stress tensor asymmetry [Pa]")
plot(stress_tensor_data$t,stress_tensor_asymmetry_linear_acceleration,type="l", ylim=c(-20,20),main="Asymmetry: Linear acceleration tensor",ylab="Stress tensor asymmetry [Pa]")#
lines(stress_tensor_data$t,stress_tensor_asymmetry_external,type="l",col="red")
path=system.file("full_python_simulation_output_example.txt",package="particleShearEvaluation")#
stress_tensor_data=read_stress_tensor_data_from_file(path)#
# Some of the stress tensors are symmetrical, some not#
#
# The classical Love-Weber tensors are not:#
stress_tensor_asymmetry_Love_Weber=stress_tensor_data$stress_tensor_Love_Weber_01-stress_tensor_data$stress_tensor_Love_Weber_10#
plot(stress_tensor_data$t,stress_tensor_asymmetry_Love_Weber,type="l", ylim=c(-20,20),main="Asymmetry: Love-Weber",ylab="Stress tensor asymmetry [Pa]")#
#
# Otsuki et al. indicate a dynamic symmetry correction; in our experience, this does not correct the problem. The Otsuki correction is indeed orders of magnitude smaller than#
# the asymmetry in the Love-Weber tensor to correct#
dev.new()#
stress_tensor_asymmetry_Otsuki=stress_tensor_data$stress_tensor_peculiar_acceleration_otsuki_01-stress_tensor_data$stress_tensor_peculiar_acceleration_otsuki_10#
plot(stress_tensor_data$t,stress_tensor_asymmetry_Otsuki,type="l", ylim=c(-20,20),main="Asymmetry: Otsuki correction term",ylab="Stress tensor asymmetry [Pa]")#
#
# Stress tensors calculated uniquely by the externally visible forces are also asymmetric#
stress_tensor_asymmetry_external=stress_tensor_data$stress_tensor_from_external_forces_01-stress_tensor_data$stress_tensor_from_external_forces_10#
plot(stress_tensor_data$t,stress_tensor_asymmetry_external,type="l", ylim=c(-20,20),main="Asymmetry: Stress tensor from surface forces",ylab="Stress tensor asymmetry [Pa]")#
#
# To symmetrize the stress tensors (Nicot et. al), one can use internal acceleration#
stress_tensor_asymmetry_linear_acceleration=stress_tensor_data$stress_tensor_linear_acceleration_01-stress_tensor_data$stress_tensor_linear_acceleration_10#
plot(stress_tensor_data$t,stress_tensor_asymmetry_linear_acceleration,type="l", ylim=c(-20,20),main="Asymmetry: Linear acceleration tensor",ylab="Stress tensor asymmetry [Pa]")#
lines(stress_tensor_data$t,stress_tensor_asymmetry_external,type="l",col="red")
stress_tensor_data[1:5,]
# To symmetrize the stress tensors (Nicot et. al), one can use internal acceleration. As above, but accounting as for Love-Weber:#
stress_tensor_asymmetry_internal_torques=stress_tensor_data$stress_tensor_internal_tangential_torque_01-stress_tensor_data$stress_tensor_internal_tangential_torque_10#
plot(stress_tensor_data$t,stress_tensor_asymmetry_internal_torques,type="l", ylim=c(-20,20),main="Asymmetry: Torque correction",ylab="Stress tensor asymmetry [Pa]")#
lines(stress_tensor_data$t,stress_tensor_asymmetry_Love_Weber,type="l",col="red")
stress_tensor_asymmetry_internal_torques=stress_tensor_data$stress_tensor_internal_tangential_torque_01-stress_tensor_data$stress_tensor_internal_tangential_torque_10#
plot(stress_tensor_data$t,stress_tensor_asymmetry_internal_torques,type="l", ylim=c(-20,20),main="Asymmetry: Torque correction",ylab="Stress tensor asymmetry [Pa]")#
lines(stress_tensor_data$t,stress_tensor_asymmetry_Love_Weber,type="l",col="red")#
legend("topleft",legend=c("internal torque correction","Love-Weber"),lty=c(1,1),col=c("black","red")
)
(stress_tensor_data$stress_tensor_internal_tangential_torque_01+stress_tensor_data$stress_tensor_Love_Weber_01)[1:100]
stress_tensor_data$shear_stress_internal_stress.tensor[1:100]
# To symmetrize the stress tensors (Nicot et. al), one can use acceleration stress tensors. The importance is matching: Here, accounting done as for the external forces#
stress_tensor_asymmetry_linear_acceleration=stress_tensor_data$stress_tensor_linear_acceleration_01-stress_tensor_data$stress_tensor_linear_acceleration_10#
plot(stress_tensor_data$t,stress_tensor_asymmetry_linear_acceleration,type="l", ylim=c(-20,20),main="Asymmetry: Linear acceleration tensor",ylab="Stress tensor asymmetry [Pa]")#
lines(stress_tensor_data$t,stress_tensor_asymmetry_external,type="l",col="red")#
legend("topleft",legend=c("linear acceleration correction of total system","external force tensor"),lty=c(1,1),col=c("black","red"))
plot(stress_tensor_data$t,stress_tensor_data$shear_stress_internal_stress.tensor,type="l",ylab="Shear stress [Pa]", ylab="Time[t]")
plot(stress_tensor_data$t,stress_tensor_data$shear_stress_internal_stress.tensor,type="l",ylab="Shear stress [Pa]", xlab="Time[t]")
path=system.file("split/stress_full_python_simulation_output_example.rda",package="particleShearEvaluation")#
stress_tensor_data=read_stress_tensor_data_from_rda_file(path)
colnames(stress_tensor_data)
300e6/1000
path
e=new.env()
load(path, envir=e)
e$stress_data
negative.binomial
getAnywhere(negative.binomial)
856*2/3
857*2/3
858*2/3
library(reproducibleCalculationTools)
help(reproducibleCalculationTools)
library(reproducibleCalculationTools)
#Example 4: rda file 2 has a different entry for a numerical variable#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number=compare_rda_contents(path_base,path_different_number)#
comparison_with_different_number
#Example 5: rda file 2 has a different entry for a numerical variable, but allow for large numerical tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number=compare_rda_contents(path_base,path_different_number,relative_numerical_tolerance=0.2)#
comparison_with_different_number
value_comparison<-function(v1,v2,verbose=TRUE,relative_numerical_tolerance=0)#
{#
    # check dimensionality, must be the same (or possibly null)#
    if(!all(dim(v1)==dim(v2)))#
    {#
        if(verbose){cat(": unequal size")}#
        return(FALSE)#
    }#
    # Check also the length in case it's vectors#
    if(!(length(v1)==length(v2)))#
    {#
        if(verbose){cat(": unequal length")}#
        return(FALSE)#
    }#
    # Either both, or none of the two variables should be NA at the same place#
    if(any(xor(is.na(v1),is.na(v2))))#
    {#
        if(verbose){cat("Mismatch in NA elements") }#
        return(FALSE)#
    }#
    comparison=(!is.na(v1) & v1==v2)|(is.na(v1) & is.na(v2))#
    comparison_OK=all(comparison)#
    # There are sometimes issues with numerical conversions in bulk comparison, so if there are problems, compare individually#
    if(!comparison_OK)#
    {#
        # Special case: dataframes, these have different types#
        if(class(v1)=="data.frame" & class(v2)=="data.frame")#
        {#
            for(colIndex in 1:(dim(v1)[2]))#
            {#
                remaining_v1 = v1[,colIndex]#
                remaining_v2 = v2[,colIndex]#
                # Mismatch in NA values#
                if(any(xor(is.na(remaining_v1),is.na(remaining_v2))))#
                {#
                    if(verbose){cat(paste(": Not all NA values match (column ", colIndex," )",sep="")) }#
                    return(FALSE)#
                }#
                remaining_v1=remaining_v1[!is.na(remaining_v1)]#
                remaining_v2=remaining_v2[!is.na(remaining_v2)]#
                # examine the critical cases that are not anyways identical#
                # Test whether they are all the same numerically#
                if(!all(remaining_v1==remaining_v2))#
                {#
                    not_identical=!(remaining_v1==remaining_v2)#
                    remaining_v1=remaining_v1[not_identical]#
                    remaining_v2=remaining_v2[not_identical]#
                    if(relative_numerical_tolerance>0)#
                    {#
                        # The values are numeric and so no conversion is needed#
                        if(is.numeric(remaining_v1) & is.numeric(remaining_v2) )#
                        {#
                            mean_val=(remaining_v1+remaining_v2)/2#
                            deviation=abs(remaining_v2-remaining_v1)#
                            if(any(deviation>relative_numerical_tolerance))#
                            {#
                                if(verbose){cat(paste(": Numerical tolerance exceeded  (column ", colIndex," )",sep="")) }#
                                return(FALSE)#
                            }#
                        } else {#
                            # Not numeric, but is conversion possible?#
                            if(suppressWarnings(!any(is.na(as.numeric(remaining_v1)))) & suppressWarnings(!any(is.na(as.numeric(remaining_v2)))))#
                            {#
                                remaining_v1=as.numeric(remaining_v1)#
                                remaining_v2=as.numeric(remaining_v2)#
                                mean_val=(remaining_v1+remaining_v2)/2#
                                deviation=abs(remaining_v2-remaining_v1)#
                                if(any(deviation>relative_numerical_tolerance))#
                                {#
                                    if(verbose){cat(paste(": Numerical tolerance exceeded  (column ", colIndex," )",sep="")) }#
                                    return(FALSE)#
                                }#
                            } else {#
                                # We can't convert all values that were unequal, and so there must be an issue#
                                if(verbose){cat(paste(": Column with unequal values is not numeric, tolerance cannot be applied  (column ", colIndex," )",sep="")) }#
                                return(FALSE)#
                            }#
                        }#
                    } else {#
                        if(verbose){cat(paste(": Numerical tolerance 0, but non-identical values  (column ", colIndex," )",sep="")) }#
                        return(FALSE)#
                    }#
                }#
            }#
            if(verbose){cat(paste(": ",TRUE,sep=""))}#
            return(TRUE)#
        }#
        problematic_v1=v1[!comparison]#
        problematic_v2=v2[!comparison]#
        # Check the the NA entries are the same#
        NA_OK=all(is.na(problematic_v1[is.na(problematic_v2)])) &#
        all(is.na(problematic_v2[is.na(problematic_v1)]))#
        if(NA_OK){#
            # Compare the potentially problematic values directly (to exclude minor issues with numerical imprecision)#
            values_OK=all(problematic_v1[!is.na(problematic_v1)]==problematic_v2[!is.na(problematic_v2)])#
            if(values_OK)#
            {#
                comparison_OK=TRUE#
            } else {#
                # This is not a reading problem, but rather a true numerical problem. In least squares fitting, particulary, this can be an issue since the implementations are not necessary exactly the same#
                # In this case, it makes sense to allow for some relative numerical tolerance#
                if(relative_numerical_tolerance>0)#
                {#
                    numerical1=as.numeric(problematic_v1[!is.na(problematic_v1)])#
                    numerical2=as.numeric(problematic_v2[!is.na(problematic_v2)])#
                    mean_val=(numerical1+numerical2)/2#
                    deviation=abs(numerical2-numerical1)#
                    if(all(deviation<relative_numerical_tolerance))#
                    {#
                        comparison_OK=TRUE#
                    }#
                }#
            }#
        }#
    }#
    if(verbose){cat(paste(": ",comparison_OK,sep=""))}#
    return(comparison_OK)#
}
value_comparison(1,2)
value_comparison(5,5.1)
value_comparison(5,5.1,relative_numerical_tolerance=1)
value_comparison(5,5.1,relative_numerical_tolerance=0.1)
value_comparison(5,5.1,relative_numerical_tolerance=0.2)
value_comparison(5,5.1,relative_numerical_tolerance=0.05)
library(reproducibleCalculationTools)
#Example 5: rda file 2 has a different entry for a numerical variable, but allow for different levels of absolute tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2)#
comparison_with_different_number
#Example 5: rda file 2 has a different entry for a numerical variable, but allow for different levels of absolute tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.3)#
comparison_with_different_number
load(path_base)
ls()
aNumber
load(path_different_number)
aNumber
#Example 5: rda file 2 has a different entry for a numerical variable, but allow for different levels of absolute tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.6)#
comparison_with_different_number
value_comparison<-function(v1,v2,verbose=TRUE,numerical_tolerance=0,relative_tolerance_evaluation=FALSE)#
{#
    # check dimensionality, must be the same (or possibly null)#
    if(!all(dim(v1)==dim(v2)))#
    {#
        if(verbose){cat(": unequal size")}#
        return(FALSE)#
    }#
    # Check also the length in case it's vectors#
    if(!(length(v1)==length(v2)))#
    {#
        if(verbose){cat(": unequal length")}#
        return(FALSE)#
    }#
    # Either both, or none of the two variables should be NA at the same place#
    if(any(xor(is.na(v1),is.na(v2))))#
    {#
        if(verbose){cat("Mismatch in NA elements") }#
        return(FALSE)#
    }#
    comparison=(!is.na(v1) & v1==v2)|(is.na(v1) & is.na(v2))#
    comparison_OK=all(comparison)#
    # There are sometimes issues with numerical conversions in bulk comparison, so if there are problems, compare individually#
    if(!comparison_OK)#
    {#
        # Special case: dataframes, these have different types#
        if(class(v1)=="data.frame" & class(v2)=="data.frame")#
        {#
            for(colIndex in 1:(dim(v1)[2]))#
            {#
                remaining_v1 = v1[,colIndex]#
                remaining_v2 = v2[,colIndex]#
                # Mismatch in NA values#
                if(any(xor(is.na(remaining_v1),is.na(remaining_v2))))#
                {#
                    if(verbose){cat(paste(": Not all NA values match (column ", colIndex," )",sep="")) }#
                    return(FALSE)#
                }#
                remaining_v1=remaining_v1[!is.na(remaining_v1)]#
                remaining_v2=remaining_v2[!is.na(remaining_v2)]#
                # examine the critical cases that are not anyways identical#
                # Test whether they are all the same numerically#
                if(!all(remaining_v1==remaining_v2))#
                {#
                    not_identical=!(remaining_v1==remaining_v2)#
                    remaining_v1=remaining_v1[not_identical]#
                    remaining_v2=remaining_v2[not_identical]#
                    if(numerical_tolerance>0)#
                    {#
                        # The values are numeric and so no conversion is needed#
                        if(is.numeric(remaining_v1) & is.numeric(remaining_v2) )#
                        {#
                            mean_val=(abs(remaining_v1)+abs(remaining_v2))/2#
                            deviation=abs(remaining_v2-remaining_v1)#
                            if(relative_tolerance_evaluation)#
                            {#
                                deviation=deviation/mean_val#
                            }#
                            if(any(deviation>numerical_tolerance))#
                            {#
                                if(verbose){cat(paste(": Numerical tolerance exceeded  (column ", colIndex," )",sep="")) }#
                                return(FALSE)#
                            }#
                        } else {#
                            # Not numeric, but is conversion possible?#
                            if(suppressWarnings(!any(is.na(as.numeric(remaining_v1)))) & suppressWarnings(!any(is.na(as.numeric(remaining_v2)))))#
                            {#
                                remaining_v1=as.numeric(remaining_v1)#
                                remaining_v2=as.numeric(remaining_v2)#
                                mean_val=(abs(remaining_v1)+abs(remaining_v2))/2#
                                deviation=abs(remaining_v2-remaining_v1)#
                                if(relative_tolerance_evaluation)#
                                {#
                                    deviation=deviation/mean_val#
                                }#
                                if(any(deviation>numerical_tolerance))#
                                {#
                                    if(verbose){cat(paste(": Numerical tolerance exceeded  (column ", colIndex," )",sep="")) }#
                                    return(FALSE)#
                                }#
                            } else {#
                                # We can't convert all values that were unequal, and so there must be an issue#
                                if(verbose){cat(paste(": Column with unequal values is not numeric, tolerance cannot be applied  (column ", colIndex," )",sep="")) }#
                                return(FALSE)#
                            }#
                        }#
                    } else {#
                        if(verbose){cat(paste(": Numerical tolerance 0, but non-identical values  (column ", colIndex," )",sep="")) }#
                        return(FALSE)#
                    }#
                }#
            }#
            if(verbose){cat(paste(": ",TRUE,sep=""))}#
            return(TRUE)#
        }#
        problematic_v1=v1[!comparison]#
        problematic_v2=v2[!comparison]#
        # Check the the NA entries are the same#
        NA_OK=all(is.na(problematic_v1[is.na(problematic_v2)])) &#
        all(is.na(problematic_v2[is.na(problematic_v1)]))#
        if(NA_OK){#
            # Compare the potentially problematic values directly (to exclude minor issues with numerical imprecision)#
            values_OK=all(problematic_v1[!is.na(problematic_v1)]==problematic_v2[!is.na(problematic_v2)])#
            if(values_OK)#
            {#
                comparison_OK=TRUE#
            } else {#
                # This is not a reading problem, but rather a true numerical problem. In least squares fitting, particulary, this can be an issue since the implementations are not necessary exactly the same#
                # In this case, it makes sense to allow for some relative numerical tolerance#
                if(numerical_tolerance>0)#
                {#
                    numerical1=as.numeric(problematic_v1[!is.na(problematic_v1)])#
                    numerical2=as.numeric(problematic_v2[!is.na(problematic_v2)])#
                    mean_val=(numerical1+numerical2)/2#
                    deviation=abs(numerical2-numerical1)#
                    if(all(deviation<numerical_tolerance))#
                    {#
                        comparison_OK=TRUE#
                    }#
                }#
            }#
        }#
    }#
    if(verbose){cat(paste(": ",comparison_OK,sep=""))}#
    return(comparison_OK)#
}
value_comparison(1,2,numerical_tolerance=3)
value_comparison(1,2,numerical_tolerance=1)
value_comparison(1,2,numerical_tolerance=1.1)
value_comparison(1,2,numerical_tolerance=1.0001)
#Example 5: rda file 2 has a different entry for a numerical variable, but allow for different levels of absolute tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.7)#
comparison_with_different_number
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-10)#
comparison_with_different_number_small_tolerance
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.7)#
comparison_with_different_number_large_tolerance
#Example 6: rda file 2 has a different entry for a numerical variable, but allow for different levels of relative tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_large_tolerance
v1=5.39
v2=6
numerical_tolerance=0.2
relative_tolerance_evaluation=TRUE
comparison=(!is.na(v1) & v1==v2)|(is.na(v1) & is.na(v2))
comparison
problematic_v1=v1[!comparison]#
        problematic_v2=v2[!comparison]
problematic
problematic_v1
library(reproducibleCalculationTools)
#Example 6: rda file 2 has a different entry for a numerical variable, but allow for different levels of relative tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_large_tolerance
v1=5.39
v2=6
value_comparison<-function(v1,v2,verbose=TRUE,numerical_tolerance=0,relative_tolerance_evaluation=FALSE)#
{#
    # check dimensionality, must be the same (or possibly null)#
    if(!all(dim(v1)==dim(v2)))#
    {#
        if(verbose){cat(": unequal size")}#
        return(FALSE)#
    }#
    # Check also the length in case it's vectors#
    if(!(length(v1)==length(v2)))#
    {#
        if(verbose){cat(": unequal length")}#
        return(FALSE)#
    }#
    # Either both, or none of the two variables should be NA at the same place#
    if(any(xor(is.na(v1),is.na(v2))))#
    {#
        if(verbose){cat("Mismatch in NA elements") }#
        return(FALSE)#
    }#
    comparison=(!is.na(v1) & v1==v2)|(is.na(v1) & is.na(v2))#
    comparison_OK=all(comparison)#
    # There are sometimes issues with numerical conversions in bulk comparison, so if there are problems, compare individually#
    if(!comparison_OK)#
    {#
        # Special case: dataframes, these have different types#
        if(class(v1)=="data.frame" & class(v2)=="data.frame")#
        {#
            for(colIndex in 1:(dim(v1)[2]))#
            {#
                remaining_v1 = v1[,colIndex]#
                remaining_v2 = v2[,colIndex]#
                # Mismatch in NA values#
                if(any(xor(is.na(remaining_v1),is.na(remaining_v2))))#
                {#
                    if(verbose){cat(paste(": Not all NA values match (column ", colIndex," )",sep="")) }#
                    return(FALSE)#
                }#
                remaining_v1=remaining_v1[!is.na(remaining_v1)]#
                remaining_v2=remaining_v2[!is.na(remaining_v2)]#
                # examine the critical cases that are not anyways identical#
                # Test whether they are all the same numerically#
                if(!all(remaining_v1==remaining_v2))#
                {#
                    not_identical=!(remaining_v1==remaining_v2)#
                    remaining_v1=remaining_v1[not_identical]#
                    remaining_v2=remaining_v2[not_identical]#
                    if(numerical_tolerance>0)#
                    {#
                        # The values are numeric and so no conversion is needed#
                        if(is.numeric(remaining_v1) & is.numeric(remaining_v2) )#
                        {#
                            mean_val=(abs(remaining_v1)+abs(remaining_v2))/2#
                            deviation=abs(remaining_v2-remaining_v1)#
                            if(relative_tolerance_evaluation)#
                            {#
                                deviation=deviation/mean_val#
                            }#
                            if(any(deviation>numerical_tolerance))#
                            {#
                                if(verbose){cat(paste(": Numerical tolerance exceeded  (column ", colIndex," )",sep="")) }#
                                return(FALSE)#
                            }#
                        } else {#
                            # Not numeric, but is conversion possible?#
                            if(suppressWarnings(!any(is.na(as.numeric(remaining_v1)))) & suppressWarnings(!any(is.na(as.numeric(remaining_v2)))))#
                            {#
                                remaining_v1=as.numeric(remaining_v1)#
                                remaining_v2=as.numeric(remaining_v2)#
                                mean_val=(abs(remaining_v1)+abs(remaining_v2))/2#
                                deviation=abs(remaining_v2-remaining_v1)#
                                if(relative_tolerance_evaluation)#
                                {#
                                    deviation=deviation/mean_val#
                                }#
                                if(any(deviation>numerical_tolerance))#
                                {#
                                    if(verbose){cat(paste(": Numerical tolerance exceeded  (column ", colIndex," )",sep="")) }#
                                    return(FALSE)#
                                }#
                            } else {#
                                # We can't convert all values that were unequal, and so there must be an issue#
                                if(verbose){cat(paste(": Column with unequal values is not numeric, tolerance cannot be applied  (column ", colIndex," )",sep="")) }#
                                return(FALSE)#
                            }#
                        }#
                    } else {#
                        if(verbose){cat(paste(": Numerical tolerance 0, but non-identical values  (column ", colIndex," )",sep="")) }#
                        return(FALSE)#
                    }#
                }#
            }#
            if(verbose){cat(paste(": ",TRUE,sep=""))}#
            return(TRUE)#
        }#
        problematic_v1=v1[!comparison]#
        problematic_v2=v2[!comparison]#
        # Check the the NA entries are the same#
        NA_OK=all(is.na(problematic_v1[is.na(problematic_v2)])) &#
        all(is.na(problematic_v2[is.na(problematic_v1)]))#
        if(NA_OK){#
            # Compare the potentially problematic values directly (to exclude minor issues with numerical imprecision)#
            values_OK=all(problematic_v1[!is.na(problematic_v1)]==problematic_v2[!is.na(problematic_v2)])#
            if(values_OK)#
            {#
                comparison_OK=TRUE#
            } else {#
                # This is not a reading problem, but rather a true numerical problem. In least squares fitting, particulary, this can be an issue since the implementations are not necessary exactly the same#
                # In this case, it makes sense to allow for some relative numerical tolerance#
                if(numerical_tolerance>0)#
                {#
                    numerical1=as.numeric(problematic_v1[!is.na(problematic_v1)])#
                    numerical2=as.numeric(problematic_v2[!is.na(problematic_v2)])#
                    mean_val=(abs(numerical1)+abs(numerical2))/2#
                    deviation=abs(numerical2-numerical1)#
                    if(relative_tolerance_evaluation)#
                    {#
                        deviation=deviation/mean_val#
                    }#
                    if(all(deviation<numerical_tolerance))#
                    {#
                        comparison_OK=TRUE#
                    }#
                }#
            }#
        }#
    }#
    if(verbose){cat(paste(": ",comparison_OK,sep=""))}#
    return(comparison_OK)#
}
numerical_tolerance=0.2
verbose=TRUE
relative_tolerance_evaluation=TRUE
!all(dim(v1)==dim(v2))
!(length(v1)==length(v2))
any(xor(is.na(v1),is.na(v2)))
comparison=(!is.na(v1) & v1==v2)|(is.na(v1) & is.na(v2))
comparison
problematic_v1=v1[!comparison]#
        problematic_v2=v2[!comparison]#
        # Check the the NA entries are the same#
        NA_OK=all(is.na(problematic_v1[is.na(problematic_v2)])) &#
        all(is.na(problematic_v2[is.na(problematic_v1)]))
NA_OK
values_OK=all(problematic_v1[!is.na(problematic_v1)]==problematic_v2[!is.na(problematic_v2)])
values_OL
values_OK
numerical_tolerance>0
numerical1=as.numeric(problematic_v1[!is.na(problematic_v1)])#
                    numerical2=as.numeric(problematic_v2[!is.na(problematic_v2)])#
                    mean_val=(abs(numerical1)+abs(numerical2))/2#
                    deviation=abs(numerical2-numerical1)#
                    if(relative_tolerance_evaluation)#
                    {#
                        deviation=deviation/mean_val#
                    }
deviation
all(deviation<numerical_tolerance)
value_comparison(5.39,6)
value_comparison(5.39,6,numerical_tolerance=0.7)
value_comparison(5.39,6,numerical_tolerance=0.2)
value_comparison(5.39,6,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)
library(reproducibleCalculationTools)
#Example 6: rda file 2 has a different entry for a numerical variable, but allow for different levels of relative tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_large_tolerance
load(paht_base)
load(path_base)
aNumber
load(path_different_number)
aNumber
library(reproducibleCalculationTools)
#Example 7: rda file 2 has a different entry for a numerical variable, but allow for different levels of relative tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_large_tolerance#
#
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_small_tolerance
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string = system.file("different_string.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string)
compare_rda_contents(path_base,path_different_string,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)
class(2)
class("string")
v1="s"
v2="t"
value_comparison<-function(v1,v2,verbose=TRUE,numerical_tolerance=0,relative_tolerance_evaluation=FALSE)#
{#
    # check dimensionality, must be the same (or possibly null)#
    if(!all(dim(v1)==dim(v2)))#
    {#
        if(verbose){cat(": unequal size")}#
        return(FALSE)#
    }#
    # Check also the length in case it's vectors#
    if(!(length(v1)==length(v2)))#
    {#
        if(verbose){cat(": unequal length")}#
        return(FALSE)#
    }#
    # Either both, or none of the two variables should be NA at the same place#
    if(any(xor(is.na(v1),is.na(v2))))#
    {#
        if(verbose){cat("Mismatch in NA elements") }#
        return(FALSE)#
    }#
    comparison=(!is.na(v1) & v1==v2)|(is.na(v1) & is.na(v2))#
    comparison_OK=all(comparison)#
    # There are sometimes issues with numerical conversions in bulk comparison, so if there are problems, compare individually#
    if(!comparison_OK)#
    {#
        # Special case: dataframes, these have different types#
        if(class(v1)=="data.frame" & class(v2)=="data.frame")#
        {#
            for(colIndex in 1:(dim(v1)[2]))#
            {#
                remaining_v1 = v1[,colIndex]#
                remaining_v2 = v2[,colIndex]#
                # Mismatch in NA values#
                if(any(xor(is.na(remaining_v1),is.na(remaining_v2))))#
                {#
                    if(verbose){cat(paste(": Not all NA values match (column ", colIndex," )",sep="")) }#
                    return(FALSE)#
                }#
                remaining_v1=remaining_v1[!is.na(remaining_v1)]#
                remaining_v2=remaining_v2[!is.na(remaining_v2)]#
                # examine the critical cases that are not anyways identical#
                # Test whether they are all the same numerically#
                if(!all(remaining_v1==remaining_v2))#
                {#
                    not_identical=!(remaining_v1==remaining_v2)#
                    remaining_v1=remaining_v1[not_identical]#
                    remaining_v2=remaining_v2[not_identical]#
                    if(numerical_tolerance>0)#
                    {#
                        # The values are numeric and so no conversion is needed#
                        if(is.numeric(remaining_v1) & is.numeric(remaining_v2) )#
                        {#
                            mean_val=(abs(remaining_v1)+abs(remaining_v2))/2#
                            deviation=abs(remaining_v2-remaining_v1)#
                            if(relative_tolerance_evaluation)#
                            {#
                                deviation=deviation/mean_val#
                            }#
                            if(any(deviation>numerical_tolerance))#
                            {#
                                if(verbose){cat(paste(": Numerical tolerance exceeded  (column ", colIndex," )",sep="")) }#
                                return(FALSE)#
                            }#
                        } else {#
                            # Not numeric, but is conversion possible?#
                            if(suppressWarnings(!any(is.na(as.numeric(remaining_v1)))) & suppressWarnings(!any(is.na(as.numeric(remaining_v2)))))#
                            {#
                                remaining_v1=as.numeric(remaining_v1)#
                                remaining_v2=as.numeric(remaining_v2)#
                                mean_val=(abs(remaining_v1)+abs(remaining_v2))/2#
                                deviation=abs(remaining_v2-remaining_v1)#
                                if(relative_tolerance_evaluation)#
                                {#
                                    deviation=deviation/mean_val#
                                }#
                                if(any(deviation>numerical_tolerance))#
                                {#
                                    if(verbose){cat(paste(": Numerical tolerance exceeded  (column ", colIndex," )",sep="")) }#
                                    return(FALSE)#
                                }#
                            } else {#
                                # We can't convert all values that were unequal, and so there must be an issue#
                                if(verbose){cat(paste(": Column with unequal values is not numeric, tolerance cannot be applied  (column ", colIndex," )",sep="")) }#
                                return(FALSE)#
                            }#
                        }#
                    } else {#
                        if(verbose){cat(paste(": Numerical tolerance 0, but non-identical values  (column ", colIndex," )",sep="")) }#
                        return(FALSE)#
                    }#
                }#
            }#
            if(verbose){cat(paste(": ",TRUE,sep=""))}#
            return(TRUE)#
        }#
        problematic_v1=v1[!comparison]#
        problematic_v2=v2[!comparison]#
        # Check the the NA entries are the same#
        NA_OK=all(is.na(problematic_v1[is.na(problematic_v2)])) &#
        all(is.na(problematic_v2[is.na(problematic_v1)]))#
        if(NA_OK){#
            # Compare the potentially problematic values directly (to exclude minor issues with numerical imprecision)#
            values_OK=all(problematic_v1[!is.na(problematic_v1)]==problematic_v2[!is.na(problematic_v2)])#
            if(values_OK)#
            {#
                comparison_OK=TRUE#
            } else {#
                # This is not a reading problem, but rather a true numerical problem. In least squares fitting, particulary, this can be an issue since the implementations are not necessary exactly the same#
                # In this case, it makes sense to allow for some relative numerical tolerance#
                if(numerical_tolerance>0)#
                {#
                    numerical1=as.numeric(problematic_v1[!is.na(problematic_v1)])#
                    numerical2=as.numeric(problematic_v2[!is.na(problematic_v2)])#
                    mean_val=(abs(numerical1)+abs(numerical2))/2#
                    deviation=abs(numerical2-numerical1)#
                    if(relative_tolerance_evaluation)#
                    {#
                        deviation=deviation/mean_val#
                    }#
                    if(all(deviation<numerical_tolerance))#
                    {#
                        comparison_OK=TRUE#
                    }#
                }#
            }#
        }#
    }#
    if(verbose){cat(paste(": ",comparison_OK,sep=""))}#
    return(comparison_OK)#
}
v1
v2
value_comparison(v1,v2)
value_comparison(v1,v2,numerical_tolerance=0.1)
numerical_tolerance=0.1
problematic_v1=v1
problematic_v2=v2
NA_OK=all(is.na(problematic_v1[is.na(problematic_v2)])) &#
        all(is.na(problematic_v2[is.na(problematic_v1)]))
NA_OK
values_OK=all(problematic_v1[!is.na(problematic_v1)]==problematic_v2[!is.na(problematic_v2)])
values_OK
as.numeric(problematic_v1[!is.na(problematic_v1)])
suppressWarnings(as.numeric(problematic_v1[!is.na(problematic_v1)]))
is.na(suppressWarnings(as.numeric(problematic_v1[!is.na(problematic_v1)])))
library(reproducibleCalculationTools)
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string = system.file("different_string.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string)#
comparison_with_different_string
# The string cannot be converted to numerical but this shouldn't interfere#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_string
# Example 9: rda file 2 has a different string value in its dataframe#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe)#
comparison_with_different_string
# The string cannot be converted to numerical but this shouldn't interfere#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_string
load(path_base)
aDataframe
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,exclude_variables="aDataframe/string_column")#
comparison_with_different_string
library(reproducibleCalculationTools)
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,exclude_variables="aDataframe/string_column")#
comparison_with_different_string
load(path_base)
aDataframe
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,exclude_variables="aDataframe/number_column")#
comparison_with_different_string
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_extra_column_dataframe = system.file("extra_column_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_extra_column_in_dataframe=compare_rda_contents(path_base,path_extra_column_dataframe)#
comparison_extra_column_in_dataframe
paste("j",c("a","b"))
library(reproducibleCalculationTools)
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
identical_comparison=compare_rda_contents(path_base,path_base)#
identical_comparison
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_one_more_variable = system.file("one_more_variable.rda",package="reproducibleCalculationTools")#
comparison_with_one_more_variable=compare_rda_contents(path_base,path_one_more_variable)#
comparison_with_one_more_variable
# Example 3: Rda file 2 has one more variable, excluded during comparison#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_one_more_variable = system.file("one_more_variable.rda",package="reproducibleCalculationTools")#
comparison_with_one_more_variable=compare_rda_contents(path_base,path_one_more_variable,exclude_variables="anotherNumber")#
comparison_with_one_more_variable
#Example 4: rda file 2 has a different entry for a numerical variable#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number=compare_rda_contents(path_base,path_different_number)#
comparison_with_different_number
#Example 5: rda file 2 has a different entry for a numerical variable, but allow for different levels of absolute tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.7)#
comparison_with_different_number_large_tolerance
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-10)#
comparison_with_different_number_small_tolerance
#Example 6: rda file 2 has a different entry for a numerical variable, but allow for different levels of relative tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_large_tolerance
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_small_tolerance
#Example 7: rda file 2 has a different entry for a numerical variable, but allow for different levels of relative tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_large_tolerance
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_small_tolerance
# Example 8: rda file 2 has a different string value#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string = system.file("different_string.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string)#
comparison_with_different_string#
# The string cannot be converted to numerical but this shouldn't interfere#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_string
# Example 9: rda file 2 has a different string value in its dataframe example#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe)#
comparison_with_different_string#
# The string cannot be converted to numerical but this shouldn't interfere#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_string
# Example 10: rda file 2 has a different string value in its dataframe example, but the column is explicitly excluded#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,exclude_variables="aDataframe/string_column")#
comparison_with_different_string
# Example 11: rda file 2 has a different string value in its dataframe example, exclusion of an unrelated column should not interfer with detection of difference#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,exclude_variables="aDataframe/number_column")#
comparison_with_different_string
# Example 12: rda file 2 has one more column in the dataframe#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_extra_column_dataframe = system.file("extra_column_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_extra_column_in_dataframe=compare_rda_contents(path_base,path_extra_column_dataframe)#
comparison_extra_column_in_dataframe
load(path_base)
ls()
aDataframe
load(path_extra_column_dataframe)
aDataframe
# Example 13: rda file 2 has one more column in the dataframe, but this difference is explicitly excluded from comparison#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_extra_column_dataframe = system.file("extra_column_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_extra_column_in_dataframe=compare_rda_contents(path_base,path_extra_column_dataframe,exclude_variables="aDataframe/extracolumn")#
comparison_extra_column_in_dataframe
library(reproducibleCalculationTools)
# Example 13: rda file 2 has one more column in the dataframe, but this difference is explicitly excluded from comparison#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_extra_column_dataframe = system.file("extra_column_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_extra_column_in_dataframe=compare_rda_contents(path_base,path_extra_column_dataframe,exclude_variables="aDataframe/extracolumn")#
comparison_extra_column_in_dataframe
# Example 12: rda file 2 has one more column in the dataframe#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_extra_column_dataframe = system.file("extra_column_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_extra_column_in_dataframe=compare_rda_contents(path_base,path_extra_column_dataframe)#
comparison_extra_column_in_dataframe
# Example 12: rda file 2 has one more column in the dataframe#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_extra_column_dataframe = system.file("extra_column_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_extra_column_in_dataframe=compare_rda_contents(path_base,path_extra_column_dataframe)#
comparison_extra_column_in_dataframe # Anticipated: FALSE
# Example 11: rda file 2 has a different string value in its dataframe example, exclusion of an unrelated column should not interfer with detection of difference#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,exclude_variables="aDataframe/number_column")#
comparison_with_different_string
# Example 10: rda file 2 has a different string value in its dataframe example, but the column is explicitly excluded#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,exclude_variables="aDataframe/string_column")#
comparison_with_different_string  # Anticipated: TRUE
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe)#
c
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string_dataframe = system.file("string_change_in_dataframe.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe)#
comparison_with_different_string # Anticipated: FALSE
# The string cannot be converted to numerical but this shouldn't interfere#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string_dataframe,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_string # Anticipated: FALSE
# Example 8: rda file 2 has a different string value#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_string = system.file("different_string.rda",package="reproducibleCalculationTools")#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string)#
comparison_with_different_string # Anticipated: FALSE#
# The string cannot be converted to numerical but this shouldn't interfere#
comparison_with_different_string=compare_rda_contents(path_base,path_different_string,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_string # Anticipated: FALSE
#Example 7: rda file 2 has a different entry for a numerical variable, but allow for different levels of relative tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_large_tolerance # Anticipated: TRUE#
#
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_small_tolerance # Anticipated: FALSE
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_small_tolerance
#Example 6: rda file 2 has a different entry for a numerical variable, but allow for different levels of relative tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.2,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_large_tolerance # Anticipated: TRUE#
#
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-6,relative_tolerance_evaluation=TRUE)#
comparison_with_different_number_small_tolerance # Anticipated: FALSE
#Example 5: rda file 2 has a different entry for a numerical variable, but allow for different levels of absolute tolerance#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number_large_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=0.7)#
comparison_with_different_number_large_tolerance # Anticipated: TRUE#
#
comparison_with_different_number_small_tolerance=compare_rda_contents(path_base,path_different_number,numerical_tolerance=1e-10)#
comparison_with_different_number_small_tolerance # Anticipated: FALSE
#Example 4: rda file 2 has a different entry for a numerical variable#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_different_number = system.file("different_single_number.rda",package="reproducibleCalculationTools")#
comparison_with_different_number=compare_rda_contents(path_base,path_different_number)#
comparison_with_different_number # Anticipated: FALSE
# Example 3: Rda file 2 has one more variable, excluded during comparison#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_one_more_variable = system.file("one_more_variable.rda",package="reproducibleCalculationTools")#
comparison_with_one_more_variable=compare_rda_contents(path_base,path_one_more_variable,exclude_variables="anotherNumber")#
comparison_with_one_more_variable # Anticipated: TRUE
# Example 2: Rda file 2 has one more variable#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
path_one_more_variable = system.file("one_more_variable.rda",package="reproducibleCalculationTools")#
comparison_with_one_more_variable=compare_rda_contents(path_base,path_one_more_variable)#
comparison_with_one_more_variable # Anticipated: FALSE
# Example 1: Compare identical rda files#
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")#
identical_comparison=compare_rda_contents(path_base,path_base)#
identical_comparison # Anticipated: TRUE
library(reproducibleCalculationTools)
value_comparison("the same","the same")
value_comparison("the same","not the same")
value_comparison("the same","the same",verbose=FALSE)
value_comparison("the same","not the same",verbose=FALSE)
value_comparison(rep("the same",5),rep("the same",5),verbose=FALSE)
value_comparison(rep("the same",5),rep("the same",5),verbose=FALSE) # Anticipated: TRUE#
value_comparison(rep("the same",5),rep("the same",4),verbose=FALSE) # Anticipated: FALSE
value_comparison(rep("the same",5),rep("the same",5),verbose=FALSE) # Anticipated: TRUE#
value_comparison(rep("the same",5),rep("the same",4),verbose=FALSE) # Anticipated: FALSE#
value_comparison(rep("the same",5),c(rep("the same",4),"not the same"),verbose=FALSE) # Anticipated: FALSE
value_comparison(4,"4",numerical_tolerance=1e-6)
value_comparison(4,"4",numerical_tolerance=1e-6,verbose=FALSE) # Explicit attempt at numerical conversion
value_comparison(4,"4") # Anticipated FALSE, without numerical tolerance, strings are considered in principle different from corresponding numbers
value_comparison(4,"4") # Anticipated TRUE, the function tries to see whether the values could not be converted to numerical
path_base = system.file("data_to_compare.rda",package="reproducibleCalculationTools")
load(path_base)
ls
ls()
aNumber
aNumber="5.3942"
value_comparison(aNumber,5.3942)
load(path_base)
value_comparison(aNumber,"5.3942")
aNumber="5.3942"
save("number_as_string.rda",list=c("aDataframe" ,"aNumber" ,    "aString"))
save(file="number_as_string.rda",list=c("aDataframe" ,"aNumber" ,    "aString"))
